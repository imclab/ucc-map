// Generated by CoffeeScript 1.6.2
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

define(function(require) {
  var BoundingBox, IO, Layer, LayersController, Mat4, Plane, Quat, Triangle2D, Vec3, rayBoxIntersection, _ref;

  Layer = require('./Layer');
  Plane = require('../geom/Plane');
  _ref = require('pex/geom'), Vec3 = _ref.Vec3, Quat = _ref.Quat, Mat4 = _ref.Mat4, Triangle2D = _ref.Triangle2D, BoundingBox = _ref.BoundingBox;
  IO = require('pex/sys').IO;
  rayBoxIntersection = function(ray, bbox, t0, t1) {
    var tmax, tmin, tymax, tymin, tzmax, tzmin;

    tmin = 0;
    tmax = 0;
    tymin = 0;
    tymax = 0;
    tzmin = 0;
    tzmax = 0;
    if (ray.direction.x >= 0) {
      tmin = (bbox.min.x - ray.origin.x) / ray.direction.x;
      tmax = (bbox.max.x - ray.origin.x) / ray.direction.x;
    } else {
      tmin = (bbox.max.x - ray.origin.x) / ray.direction.x;
      tmax = (bbox.min.x - ray.origin.x) / ray.direction.x;
    }
    if (ray.direction.y >= 0) {
      tymin = (bbox.min.y - ray.origin.y) / ray.direction.y;
      tymax = (bbox.max.y - ray.origin.y) / ray.direction.y;
    } else {
      tymin = (bbox.max.y - ray.origin.y) / ray.direction.y;
      tymax = (bbox.min.y - ray.origin.y) / ray.direction.y;
    }
    if ((tmin > tymax) || (tymin > tmax)) {
      return 0;
    }
    if (tymin > tmin) {
      tmin = tymin;
    }
    if (tymax < tmax) {
      tmax = tymax;
    }
    if (ray.direction.z >= 0) {
      tzmin = (bbox.min.z - ray.origin.z) / ray.direction.z;
      tzmax = (bbox.max.z - ray.origin.z) / ray.direction.z;
    } else {
      tzmin = (bbox.max.z - ray.origin.z) / ray.direction.z;
      tzmax = (bbox.min.z - ray.origin.z) / ray.direction.z;
    }
    if ((tmin > tzmax) || (tzmin > tmax)) {
      return 1;
    }
    if (tzmin > tmin) {
      tmin = tzmin;
    }
    if (tzmax < tmax) {
      tmax = tzmax;
    }
    if (tmin > 0 && tmax > 0) {
      return 2;
    }
    return -2;
  };
  return LayersController = (function() {
    LayersController.prototype.compactLayers = false;

    LayersController.prototype.enabled = true;

    function LayersController(window, scene, camera) {
      var _this = this;

      this.window = window;
      this.scene = scene;
      this.camera = camera;
      this.loadLayers = __bind(this.loadLayers, this);
      this.up = new Vec3(0, 1, 0);
      this.selectedLayer = null;
      this.dragCenter = new Vec3();
      this.dragStart = new Vec3();
      this.dragDelta = new Vec3();
      this.dragScale = new Vec3();
      this.dragStartRotationAngle = 0;
      this.loadLayers('layers.txt');
      this.window.on('mouseMoved', function(e) {
        if (!_this.enabled) {
          return;
        }
        return _this.testHit(e);
      });
      this.window.on('leftMouseDown', function(e) {
        var hits, ray;

        if (!_this.enabled) {
          return;
        }
        if (_this.selectedLayer) {
          ray = _this.camera.getWorldRay(e.x, e.y, _this.window.width, _this.window.height);
          hits = ray.hitTestPlane(_this.selectedLayer.position, _this.up);
          _this.dragCenter.setVec3(_this.selectedLayer.position);
          _this.dragStart.setVec3(hits[0]);
          _this.dragDelta.asSub(hits[0], _this.selectedLayer.position);
          _this.dragScale.setVec3(_this.selectedLayer.scale);
          _this.dragRotationInit = false;
          return _this.dragRotationStartAngle = _this.selectedLayer.rotationAngle;
        }
      });
      this.window.on('mouseDragged', function(e) {
        var angle, currentDistance, dragRotationDiffAngle, hits, originalDistance, radians, ray, scaleRatio;

        if (!_this.enabled) {
          return;
        }
        if (_this.selectedLayer) {
          ray = _this.camera.getWorldRay(e.x, e.y, _this.window.width, _this.window.height);
          hits = ray.hitTestPlane(_this.selectedLayer.position, _this.up);
          if (!e.shift && !e.option) {
            _this.selectedLayer.position.setVec3(hits[0]).sub(_this.dragDelta);
          }
          if (e.shift) {
            originalDistance = _this.dragStart.distance(_this.dragCenter);
            currentDistance = hits[0].distance(_this.dragCenter);
            scaleRatio = currentDistance / originalDistance;
            _this.selectedLayer.scale.set(_this.dragScale.x * scaleRatio, _this.dragScale.y * scaleRatio, _this.dragScale.z * scaleRatio);
          }
          if (e.option) {
            _this.dragDelta.asSub(hits[0], _this.selectedLayer.position);
            radians = Math.atan2(-_this.dragDelta.z, _this.dragDelta.x);
            angle = Math.floor(radians * 180 / Math.PI);
            if (!_this.dragRotationInit) {
              _this.dragRotationInit = true;
              _this.dragRotationBaseAngle = angle;
            }
            dragRotationDiffAngle = angle - _this.dragRotationBaseAngle;
            _this.selectedLayer.rotationAngle = _this.dragRotationStartAngle + dragRotationDiffAngle;
          }
          return e.handled = true;
        }
      });
      this.window.on('keyDown', function(e) {
        if (!_this.enabled) {
          return;
        }
        switch (e.str) {
          case '-':
            if (_this.selectedLayer) {
              _this.selectedLayer.alpha = Math.max(0, _this.selectedLayer.alpha - 0.1);
            }
            break;
          case '=':
            if (_this.selectedLayer) {
              _this.selectedLayer.alpha = Math.min(1, _this.selectedLayer.alpha + 0.1);
            }
            break;
          case 'S':
            _this.saveLayers('layers.txt');
            break;
          case 'L':
            _this.loadLayers('layers.txt');
        }
        switch (e.keyCode) {
          case 48:
            return _this.toggleCompactLayers();
        }
      });
    }

    LayersController.prototype.toggleCompactLayers = function() {
      var _this = this;

      this.compactLayers = !this.compactLayers;
      return this.scene.drawables.forEach(function(drawable, i) {
        if (drawable instanceof Layer) {
          return drawable.position.y = _this.compactLayers ? drawable.level * 0.005 : drawable.level * 0.1;
        }
      });
    };

    LayersController.prototype.saveLayers = function(fileName) {
      var data,
        _this = this;

      console.log('LayersController.saveLayers ' + fileName);
      data = {};
      this.scene.drawables.forEach(function(drawable, i) {
        var layer;

        if (drawable instanceof Layer) {
          layer = drawable;
          return data[layer.name] = {
            position: layer.position,
            scale: layer.scale,
            rotationAngle: layer.rotationAngle
          };
        }
      });
      return IO.saveTextFile(fileName, JSON.stringify(data));
    };

    LayersController.prototype.loadLayers = function(fileName) {
      var _this = this;

      console.log('LayersController.loadLayers ' + fileName);
      return IO.loadTextFile(fileName, function(dataStr) {
        var data;

        data = JSON.parse(dataStr);
        return _this.scene.drawables.forEach(function(drawable, i) {
          var layer;

          if (drawable instanceof Layer) {
            layer = drawable;
            if (!data[layer.name]) {
              return;
            }
            layer.position.x = data[layer.name].position.x;
            layer.position.y = data[layer.name].position.y;
            layer.position.z = data[layer.name].position.z;
            layer.scale.x = data[layer.name].scale.x;
            layer.scale.y = data[layer.name].scale.y;
            layer.scale.z = data[layer.name].scale.z;
            return layer.rotationAngle = data[layer.name].rotationAngle;
          }
        });
      });
    };

    LayersController.prototype.testHit = function(e) {
      var hitLayers, hitPoints, ray,
        _this = this;

      ray = this.camera.getWorldRay(e.x, e.y, this.window.width, this.window.height);
      hitLayers = [];
      hitPoints = [];
      this.scene.drawables.forEach(function(drawable, i) {
        var bbox, corners, corners2d, hit, hit2d, hits, plane, triangle1, triangle2;

        if (drawable instanceof Layer && i > 0) {
          if (drawable.enabled === false) {
            return;
          }
          drawable.selected = false;
          hits = ray.hitTestPlane(drawable.position, _this.up);
          bbox = BoundingBox.fromPoints(drawable.planeMesh.geometry.vertices);
          plane = new Plane(drawable.position, _this.up);
          if (hits.length > 0) {
            hit = hits[0];
            hit2d = plane.rebase(plane.project(hit));
            corners = [new Vec3(bbox.min.x, bbox.max.y, bbox.min.z), new Vec3(bbox.max.x, bbox.max.y, bbox.min.z), new Vec3(bbox.max.x, bbox.max.y, bbox.max.z), new Vec3(bbox.min.x, bbox.max.y, bbox.max.z)];
            corners = corners.map(function(v) {
              return v.dup().transformMat4(drawable.planeMesh.modelWorldMatrix);
            });
            corners2d = corners.map(plane.project.bind(plane)).map(plane.rebase.bind(plane));
            triangle1 = new Triangle2D(corners2d[0], corners2d[1], corners2d[2]);
            triangle2 = new Triangle2D(corners2d[0], corners2d[2], corners2d[3]);
            if (triangle1.contains(hit2d) || triangle2.contains(hit2d)) {
              return hitLayers.push(drawable);
            }
          }
        }
      });
      if (hitLayers.length > 0) {
        hitLayers.sort(function(a, b) {
          return -(a.position.y - b.position.y);
        });
        this.selectedLayer = hitLayers[0];
        return this.selectedLayer.selected = true;
      } else {
        return this.selectedLayer = null;
      }
    };

    return LayersController;

  })();
});
